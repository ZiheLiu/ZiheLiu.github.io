---
title: 最大堆
date: 2020-03-05 17:21:00
categories:
	- algorithm
tags:
	- algorithm
mathjax: true
---

# 引用
-  [为什么建堆的时间复杂度是O(n)？](https://blog.csdn.net/LeoSha/article/details/46116959)
-  [最大堆（创建、删除、插入和堆排序）](https://www.jianshu.com/p/21bef3fc3030)

# 简介

最大堆为完全二叉树。对于每一个子树，它的根节点的值比两个孩子都大。

用数组 `nums` 实现，`nums[1]` ~ `nums[length]` 存储值。

# 插入节点

1. 插入**最后一个位置** $length + 1$。
  
   因为插入后，最后一个节点所在的子树不符合最大堆的性质，所以进行如下的上浮调整。
   
2. **上浮调整**。把当前节点的值和父节点比较。

   - 如果大于父节点的值，则插入完成，退出。

   - 如果小于父节点的值，则把当前节点和父节点进行调换，调换后的父节点作为当前节点，重复步骤 2。

# 删除节点

1. 首先把**根节点**  `nums[1]` 与最后一个节点 `nums[length]` 交换位置。
  
   相当于删除了根节点，为了删除后还是一个完全二叉树，所以只能把左后一个节点移动到头部。
   
2. 进行**下沉调整**。比较当前节点和两个子节点中值更大的节点，

   - 如果当前节点大，则删除完成，退出。
   - 如果当前节点小，则把当前节点和这个子节点调换，调换完成后的子节点作为当前节点，重复步骤(2)。

# 创建最大堆

1. 将所有数字按顺序直接填到 nums 中。

2. 从**最后一个非叶子**节点开始调整，每次**向下**调整节点对应的子树。

   因为最后叶子节点下标为 n、它的父节点是最后一个非叶子节点，所以最后一个非叶子节点的下标为n / 2。

时间复杂度：$O(n)$。

## 证明过程

1. 具有$n$个元素的平衡二叉树，树高为$log(n)$，我们设这个变量为$h$。
2. 最下层非叶节点的元素，只需做一次线性运算便可以确定大根，而这一层具有$2^{h-1}$个元素，我们假定$O(1)=1$，那么这一层元素所需时间为$2^{h-1}*1$。
3. 由于是bottom-top建立堆，因此在调整上层元素的时候，并不需要同下层所有元素做比较，只**需要同其中之一分支作比较**，而作比较次数则是树的高度减去当前节点的高度。因此，第$x$层元素的计算量为$2^x*(h-x)$。
4. 又以上通项公式可得知，构造树高为h的二叉堆的精确时间复杂度为： 
   `$S = 2^{h-1}*1 + 2^{h-2}*2 + …… +1* (h-1) $` ①

通过观察第四步得出的公式可知，该求和公式为等差数列和等比数列的乘积，因此用错位想减发求解，给公式左右两侧同时乘以2，可知： 

`$2S = 2^h*1 + 2^{h-1}*2+ …… +2 × (h-1)$` ②

用②减去①可知： $S =2^h * 1 - h +1$ ③

将$h = log(n)$带入③，得出如下结论：

$S = n - log(n) +1 = O(n)$

结论：构造二叉堆的时间复杂度为线性得证。