---
title: 同步/异步IO与阻塞/非阻塞IO
date: 2020-03-05 19:18:00
categories:
	- network
tags:
	- network
	- io
typora-root-url: ../../
---

对于读/写 I/O 操作，流程分为两步（以读事件为例）：

1. 等待数据准备好。（例如从网络来的数据写入网卡、再复制进内核）。

2. 数据从内核空间复制到用户空间。

# 阻塞与非阻塞 I/O

阻  I/O 和非阻塞 I/O 是看在调用 `read()`接口时，在阶段 1 数据没有准备好时，处理的方法。

- 阻塞 I/O 调用 read()` 接口在数据没有准备好时，会阻塞在这个系统调用出。（这个进程被放入了等待队列）。
- 非阻塞 I/O 调用 `read()` 接口在数据没有准备好时，会直接返回失败。

![阻塞I/O](/images/阻塞io.jpg)
![非阻塞I/O](/images/非阻塞io.jpg)

# 同步与异步 I/O

同步 I/O 和异步 I/O 是看在有数据可读时，是否要等待从内核拷贝到用户空间的过程。

- 同步 I/O 在有数据可读时，会等待从内核拷贝到用户的过程。
- 异步 I/O 在有数据可读时，会继续做其他的，等内核已经拷贝数据到用户空间，再进行数据的处理。

 ![异步I/O](/images/异步io.jpg)



# Netty 使用的 NIO，为什么说自己是异步事件驱动的

Netty 的网络模型是**同步非阻塞**的，并不是 AIO 异步的网络模型。

Netty 说的异步，是伪异步。异步事件驱动框架体现在所有的 I/O 操作是异步的，所有的 I/O 调用会立即返回，并不保证调用成功与否，但是调用会返回 `ChannelFuture`，Netty 会通过`ChannelFuture` 通知你调用是成功了还是失败了亦或是取消了。

# 为什么 Netty 使用 NIO 而不是 AIO

> [为什么Netty使用NIO而不是AIO？](https://www.jianshu.com/p/df1d6d8c3f9d)

- Netty的目标主要是Linux系统，AIO在linux上是使用Epoll实现，没有很好实现AIO，因此在性能上没有明显的优势。
- 被JDK封装了一层不容易深度优化。
- Netty整体架构是reactor模型, 而AIO是proactor模型, 混合在一起会非常混乱。
- AIO还有个缺点是接收数据需要预先分配缓存, 而不是NIO那种需要接收时才需要分配缓存, 所以对**连接数量非常大但流量小**的情况, 内存浪费很多。
