---
title: 同步/异步IO与阻塞/非阻塞IO
date: 2020-03-05 19:18:00
categories:
	- network
tags:
	- network
	- io
typora-root-url: ../../
---

对于读/写 I/O 操作，流程分为两步（以读事件为例）：

1. 等待数据准备好。（例如从网络来的数据写入网卡、再复制进内核）。

2. 数据从内核空间复制到用户空间。

# 阻塞与非阻塞 I/O

阻  I/O 和非阻塞 I/O 是看在调用 `read()`接口时，在阶段 1 数据没有准备好时，处理的方法。

- 阻塞 I/O 调用 read()` 接口在数据没有准备好时，会阻塞在这个系统调用出。（这个进程被放入了等待队列）。
- 非阻塞 I/O 调用 `read()` 接口在数据没有准备好时，会直接返回失败。

![阻塞I/O](/images/阻塞io.jpg)
![非阻塞I/O](/images/非阻塞io.jpg)

# 同步与异步 I/O

同步 I/O 和异步 I/O 是看在有数据可读时，是否要等待从内核拷贝到用户空间的过程。

- 同步 I/O 在有数据可读时，会等待从内核拷贝到用户的过程。
- 异步 I/O 在有数据可读时，会继续做其他的，等内核已经拷贝数据到用户空间，再进行数据的处理。

 ![异步I/O](/images/异步io.jpg)



# Netty 使用的 NIO，为什么说自己是异步事件驱动的

Netty 的网络模型是**同步非阻塞**的，并不是 AIO 异步的网络模型。

Netty 说的异步，是伪异步。异步事件驱动框架体现在所有的 I/O 操作是异步的，所有的 I/O 调用会立即返回，并不保证调用成功与否，但是调用会返回 `ChannelFuture`，Netty 会通过`ChannelFuture` 通知你调用是成功了还是失败了亦或是取消了。

# 为什么 Netty 使用 NIO 而不是 AIO

> [为什么Netty使用NIO而不是AIO？](https://www.jianshu.com/p/df1d6d8c3f9d)

- Netty的目标主要是Linux系统，AIO在linux上是使用Epoll实现，没有很好实现AIO，因此在性能上没有明显的优势。
- 被JDK封装了一层不容易深度优化。
- Netty整体架构是reactor模型, 而AIO是proactor模型, 混合在一起会非常混乱。
- AIO还有个缺点是接收数据需要预先分配缓存, 而不是NIO那种需要接收时才需要分配缓存, 所以对**连接数量非常大但流量小**的情况, 内存浪费很多。

# Reactor和Preactor模式

Reactor模式是针对同步IO网络模式，Preactor模式是针对异步IO网络模式。

## Reactor模式组成

> [IO多路复用之Reactor](https://www.cnblogs.com/amei0/p/8117660.html)

- 描述符 handle 。由操作系统提供的资源，用于识别每一个事件，如Socket描述符、文件描述符、信号的值等。在Linux中，它用一个整数来表示。事件可以来自外部，如来自客户端的连接请求、数据等。事件也可以来自内部，如信号、定时器事件。

- 同步事件多路分离器（event demultiplexer）。事件的到来是随机的、异步的，无法预知程序何时收到一个客户连接请求或收到一个信号。所以程序要循环等待并处理事件，这就是事件循环。在事件循环中，等待事件一般使用I/O复用技术实现。在linux系统上一般是select、poll、epol_waitl等系统调用，用来等待一个或多个事件的发生。I/O框架库一般将各种I/O复用系统调用封装成统一的接口，称为事件多路分离器。调用者会被阻塞，直到分离器分离的描述符集上有事件发生。

- 事件处理器（event handler）。I/O框架库提供的事件处理器通常是由一个或多个模板函数组成的接口。这些模板函数描述了和应用程序相关的对某个事件的操作，用户需要继承它来实现自己的事件处理器，即具体事件处理器。因此，事件处理器中的回调函数一般声明为虚函数，以支持用户拓展。

- 具体的事件处理器（concrete event handler）。是事件处理器接口的实现。它实现了应用程序提供的某个服务。每个具体的事件处理器总和一个描述符相关。它使用描述符来识别事件、识别应用程序提供的服务。

- Reactor 管理器（reactor）。定义了一些接口，用于应用程序控制事件调度，以及应用程序注册、删除事件处理器和相关的描述符。它是事件处理器的调度核心。 Reactor管理器使用同步事件分离器来等待事件的发生。一旦事件发生，Reactor管理器先是分离每个事件，然后调度事件处理器，最后调用相关的模 板函数来处理这个事件。

总的来说，Reactor管理器调用事件分离器等待事件的发生，事件发生后Reactor管理器被唤醒，调度事件处理器链进行事件的处理。