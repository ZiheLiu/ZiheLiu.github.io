---
title: 2. Java垃圾收集器与内存分配分配策略
date: 2020-03-04 14:48:52
tags:
	- java
	- jvm
categories:
	- java
	- jvm
typora-root-url: ../../../
---

# 引用

- 《深入理解 Java 虚拟机-第三版》
- [java中虚引用PhantomReference与弱引用WeakReference（软引用SoftReference）的差别](https://blog.csdn.net/aitangyong/article/details/41358427)

#  简介

## 堆和方法区的垃圾回收
- 程序计数器、虚拟机栈、本地方法栈不需要垃圾回收。
  - 所需要分配的内存在编译器可以确定下来，内存分配和回收具有确定性。
- 堆和方法区，内存的分配和回收是动态的。
  - 一个接口的多个实现类需要的内存可能不同。
  - 一个方法不同的条件分支所需要的内存可能不同。

## 垃圾回收需要完成的三件事

1. 哪些内存需要回收？
2. 什么时候回收？
3. 如何回收？

# 哪些对象需要回收

## 没有使用引用计数的原因

有很多例外情况要考虑，要配合大量额外处理才能保证正确地工作。例如循环引用。

## 核心算法：可达性分析

- GC Roots：通过一系列 “GC Roots” 的根对象作为起始节点集。

- 引用链：从 GC Roots 开始，根据引用关系向下搜索，搜索过程所走过的路径。

如果某个对象到 GC Roots 没有引用链相连，即从 GC Roots 到这个对象不可达时，说明对象是不可能再被使用的。

### 对象不可达与 `finalize()`

对象不可达并**不一定**会被回收。

如果对象重写了 `finalize()` 函数、并且还没有被 JVM 调用过 。会**进行两次标记**。

1. 第一次标记。在对象不可达时进行第一次标记。随后，把对象加入到 `F-Queue` 队列中，在虚拟机的优先级的 Finalizer 线程去执行他们的 `finalize()` 方法。
2. 第二次标记。收集器对 `F-Queue` 中的对象进行第二次标记。如果对象“拯救”了自己（把自己赋值给其他变量），就从“即将回收”的集合中移除。

`finalize()` 方法需要注意的点：

- 并**不保证**会等待它运行完毕，否则某些 `finalize()` 执行很缓慢、死循环，会导致其他`finalize()` 无法被执行。
- 每个对象的 `finalize()` 只会执行一次。也就是每个对象只能“拯救”自己一次。

## 作为 GC Roots 的对象

固定的。

1. 虚拟机栈的本地变量表中引用的对象。
2. 本地方法栈中引用的对象。
3. 方法区中类静态属性引用的对象。
4. 方法区中常量引用的对象。例如字符串常量池里的引用。
5. 被监视器锁 `synchronized` 持有的对象。
6. JVM 内部的引用
   - 常驻的异常对象（NullPointException、OutOfMemoryError等）。
   - 系统类加载器。
   - 基本数据类型对应的 Class 对象。
7. 反 JVM 内部情况的 JMXBean、JVMTI 中注册的回调、本地代码缓存等。

临时的。

- 分代回收、局部回收会把堆内存划分区域，相关联区域的对象也要加入到 GC Roots 中。

## 种引用类别

1. 强引用。
   - 强引用关系存在，垃圾收集器就不会回收被引用的对象。
2. 软引用。
   - 描述还有用、非必须的对象。
   - **只**被软引用的对象，在系统要发生内存溢出异常时，把这些对象纳入回收范围，进行第二次回收。
   - `SoftReference` 类。
     - `SoftReference#get()` 方法返回引用的对象。
     - 在被 GC 时，会把引用的对象置为 null，再加入到 `ReferenceQueue` 中。
3. 弱引用。
   - 描述非必须的对象。
   - **只**被弱引用的对象，下次垃圾收集就会回收掉。
   - `WeakReference` 类。
     - `WeakReference#get()` 方法返回引用的对象。
     - 在被 GC 时，会把引用的对象置为 null，再加入到 `ReferenceQueue` 中。
4. 虚引用。
   - 用来在这个对象被垃圾回收时收到系统通知。
   - `PhantomReference` 类。
     - `PhantomReference#get()` 方法返回 null，即无法通过虚引用得到被引用的对象。
     - 在被 GC 时，会把引用的对象不会置为 null，直接加入到 `ReferenceQueue` 中。
     - 需要手动调用 `PhantomReference#clear()` 才会清除弱引用的对象。如果不清楚，可能会**内存泄漏**！！

## 回收方法区

方法区主要回收两部分内容：

- 废弃的常量。没有任何字符串对象引用、且虚拟机中也没有其他地方引用这个字面量。

- 无用的类型。需要满足 3 个条件：

  1. 该类所有的实例都已被回收。
  
  2. 该类的类加载器已被回收。
  
  3. 该类对应的 `java.lang.Class` 对象没有在任何地方被引用。

在满足上述条件的时候，如果发生了 GC，废弃的常量、无用的类型可以被回收掉。

但是并不是一定会回收，HotSpot 虚拟机提供 `-Xnoclassgc` 参数对类型的写在进行控制。

# 垃圾收集算法

## 理论基础

### 三个分代假说

1. 弱分代假说：绝大多数对象都是朝生夕灭的。

2. 强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡。
3. 跨代引用假说：跨代引用相对于同代引用来说仅占极少数。

### 分代收集

因此可以根据对象的年龄，把堆内存划分成不同的区域。

- 新生代。区域内大部分都是朝生夕灭的对象，只需要关注如何保留少量存活的对象。
- 老年代。区域内都是难以消亡的对象，可以使用较低的频率来回收这个区域。

### 记忆集

对象不是孤立的，对象之间会存在跨代引用。因此，在 GC 时，需要知道老年代的对象引用了哪些新生代的对象。

根据假说 3，只存在极少量的跨代引用。不必要专门记录每个对象存在哪些跨代引用，只需在新生代上建立一个全局的数据结构“记忆集” `RememberedSet`。

- 老年代分块。标识出老年代的哪一块内存会存在跨代引用。
- 部分块加入 GC Roots。发生 MinorGC 时，只有包含了跨代引用的小块内存里的对象才会被加入到 GC Roots 进行扫描。
- 需要在对象改变引用关系时维护记录数据的正确性，但是不必要 GC 时，扫描整个老年代。

### 收集的分类

- 部分收集 PartialGC。指目标不是完整收集整个 Java 堆的垃圾收集。分为：
  - 新生代收集 MinorGC/YoungGC。指目标只是新生代的垃圾收集。
  - 老年代收集 MajorGC/OldGC。指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。
  - 混合收集 MixedGC。指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。
- 整堆收集 FullGC。收集整个Java堆和**方法区**的垃圾收集。

## 标记-清除算法

两个阶段：

1. 标记出所有需要回收的对象。
2. 统一回收掉所有被标记的对象。

两个缺点：

1. 执行效率不稳定。如果堆中包含大量对象、且大部分需要回收。需要进行大量的标记和清除操作。
2. 内存空间的碎片化。会产生大量不连续的内存碎片，在之后分配大对象时无法找到足够大的连续区域，就需要提前触发一次 GC。（见CMS-TODO）

## 标记-复制算法

HotSpot 的做法：

- 把新生代分为较大的 Eden 区、较小的 FromSurvivor 区、ToSurvivor 区。默认是 `8:1:1`。
- 分配内存时，只使用 Eden 区、FromSurvivor 区。
- GC 时，将 Eden 区、FromSurvivor 区存活的对象复制到 ToSurvivor 区。清理掉 Eden 区、FromSurvivor 区。
- 当一块 Survivor 空间不足以容纳一次 MinorGC 之后存活的对象时，需要依赖老年代进行分配担保。

缺点：

- 在对象存活率较高时，要进行较多的复制操作。


## 标记-整理算法

### 两个阶段

1. 标记出所有需要回收的对象。
2. 让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。

### 优点

- 不会像**标记-清除**算法那样产生内存空间碎片。

### 缺点

- 在对象存活率较高时，操作的负担很重。
- 需要暂停用户程序。

### 与标记-清除算法的对比。

- 标记-清除算法的延时较低。GC 时，直接清除、不移动对象，停顿时间更短。
- 标记-整理算法的吞吐量较高。指用户程序执行时间/(用户程序执行时间+GC 时间)。
  - 虽然 GC 时移动对象效率低；
  - 但整理内存后，内存分配、访问效率很高。
  - 而且内存分配和访问相比 GC 频率要高得多。因此吞吐量是更高的。

### 与标记-清除算法结合使用

CMS 收集器平时使用标记-清除算法，在内存空间很大，无法分配对象时，再使用标记-整理算法收集一次。（见CMS-TODO）

# HotSpot 的算法细节实现

## 根节点枚举

方法区大小数百兆，类、常量的数量很多。栈中也类似。

虚拟机需要有办法直接得到哪些地方存放着对象引用。

HotSpot 使用 `OopMap` (Ordinary Object Pointer) 来实现这个功能，会在**特定位置**记录下栈、寄存器里哪些位置是引用。

## 安全点

不能每一条指令都记录到 `OopMap`，空间成本太高。只能在**特定位置**记录。这些位置就是**安全点**。

用户程序只有执行到安全点后才能暂停。

- 如何选择安全点？
  - 标准是“是否具有让程序长时间执行的特征”，指令序列的复用，例如方法调用、循环跳转、异常跳转。
  - 只有具有这些功能的指令才会产生安全点。
- 如何让所有线程都执行到最近的安全点？
  - 主动式中断。设置一个标志位。线程执行时不断主动去轮询这个标志，如果发现中断标志位真，就在最近的安全点主动挂起。
  - 轮询的位置：安全点、以及分配堆内存时（避免没有足够内存分配新对象）。
  - 实现方式：内存保护陷阱。
    - JVM 把这个指令要读的内存页被设置为不可读，
    - 用户线程执行到这条指令时，就会产生自陷异常信号，在异常处理器中挂起线程，实现等待。

## 安全区域

如果程序在阻塞，就无法响应 JVM 的中断请求，无法走到安全点挂起自己。使用安全区域来解决。

安全区域，指能够确保在某一段代码片段中，引用关系不会发生变化。在安全区域进行垃圾收集都是安全的。

- 用户线程执行到安全区域的代码时，标识自己进入了安全区。这段时间 JVM 要发起垃圾收集，就不需要管在安全区域的线程。
- 用户线程离开安全区域时，需要等待 JVM 完成了根节点的枚举。

## 记忆表与卡表

HotSpot 使用卡表 CARD_TABLE，一个字节数组来实现记忆表。

每个元素表示一个内存块（卡页）是否存在跨代指针，如果存在，则标为 0 （变脏）。

## 写屏障

需要提供机制来使**维护卡表**的动作放到赋值操作中。

**写屏障**可以在**引用类型字段赋值**指令前后产生环形通知，供程序执行额外的动作。

### 伪共享

如果不同线程更新的对象所对应的卡表项处于同一个缓存行，就会导致缓存不断写回、失效。

不采用无条件的写屏障，先检查卡表项是否为 0，如果是 0，才进行写入。

## 并发的可达性分析

在确定 GC Roots 后，可以使 JVM 对引用链的可达性分析、与用户线程并发执行。

### 三色标记

- 白色：还没有被垃圾收集器访问过。
- 黑色：对象被垃圾收集器访问过，其所有引用都被扫描过了。（GC Roots 要设为黑色的）。
- 灰色：对象被垃圾收集器访问过，至少存在一个引用没有被扫描过。

### 对象消失问题

并发分析引用链时，用户线程（赋值器）可能改变了引用关系。

在同时满足如下两个关系时，会把还有引用的对象错误的标记为白色：

- 赋值器插入了从黑色节点到白色节点的新引用。
- 赋值器删除了从灰色节点到这个白色节点的所有直接、间接引用。

### 解决办法

只要破坏上述其中一个条件就可以。通过写屏障实现。

- 增量更新。
  - 在黑色节点插入到白色节点的新引用时，记录下来这个引用。
  - 在并发扫描结束后，从这些记录的黑节点为根，再扫描一次。
- 原始快照。
  - 在灰色对象要删除指向白色节点的引用时，记录下来要删除的引用。
  - 在并发扫描结束后，从这些记录的灰色节点为根，再扫描一次。

# 经典垃圾收集器

## 简介

### HotSpot垃圾收集器

图中连线的说明可以配合使用。

![HotSpot垃圾收集器](/images/HotSpot垃圾收集器.png)

### 对比

| 名称              | 针对区域           | 线程数                         | 是否暂停 | 算法                     | GC 操作  |
| ----------------- | ------------------ | ------------------------------ | -------- | ------------------------ | -------- |
| Serial            | 新生代             | 单线程                         | 暂停     | 标记-复制                | Minor GC |
| Serial Old        | 老年代             | 单线程                         | 暂停     | 标记-整理                | Full GC  |
| ParNew            | 新生代             | 多线程                         | 暂停     | 标记-复制                | Minor GC |
| Parallel Scavenge | 新生代             | 多线程                         | 暂停     | 标记-复制                | Minor GC |
| Parallel Old      | 老年代             | 多线程                         | 暂停     | 标记-整理                | Full GC  |
| CMS               | 老年代             | 初始标记单线程<br />其他多线程 | 部分暂停 | 标记-清理                | Major GC |
| G1                | 新生代<br />老年代 | 初始标记单线程<br />其他多线程 | 部分暂停 | 从Region复制到其他Region |          |

- 只有 CMS 有Marjor GC。其他收集器没有专门在老年代进行 GC的。要进行老年代 GC，他们都是进行 Full GC。

## Serial 收集器

- 新生代收集器。
- 单线程工作。
- 垃圾收集时，需要暂停工作线程。
- 采用**标记-复制**算法。
- 客户端模式下默认的新生代收集器。

## Serial Old 收集器

- 老年代收集器。Serial 的老年代版本。
- 单线程工作。
- 使用**标记-整理**算法。对整堆进行 Full GC，不是只针对老年代。

## ParNew 收集器

- 新生代收集器。

- ParNew 只是在新生代时，多线程工作。其他和 Serial 一样。

## Parallel Scavenge 收集器

- 新生代收集器。
- 多线程工作。
- 垃圾收集时，需要暂停工作线程。
- 采用**标记-复制**算法。
- 侧重吞吐量。更有效的利用处理器资源，适合后台计算任务。
  - `-XX:MaxGCPauseMills` 收集器尽力保证垃圾回收的时间不超过这个值。
  - `-XX:GCTimeRatio` 垃圾收集时间占总时间的比率，吞吐量的导数。
  - `-XX+UseAdpativeSizePolicy` 自调整新生代大小、Eden与Survivor遍历、晋升老年代的年龄等参数，以提供最合适的停顿时间、或最大的吞吐量。

## Parallel Old 收集器

- 老年代收集器。Parallel Scavenge 的老年代版本。
- 多线程工作。
- 垃圾收集时，需要暂停工作线程。
- 采用**标记-整理**算法。对整堆进行 Full GC，不是只针对老年代。

## CMS 收集器

CMS 指 Concurrent Mark Sweep。

- 老年代收集器。

- 多线程工作。

- 部分步骤与用户线程并发。

  1. 初始标记。

     - 单线程。

     - 需要暂停。

     - 标记 GC Roots 能直接关联的对象。

  2. 并发标记。

     - 多线程。

     - 不需要暂停。

     - 从 GC Roots 直接关联的对象遍历整个对象图。

  3. 重新标记。

     - 多线程。
     - 需要暂停。
     - 修正并发标记时，用户程序继续运作产生变动的对象（见三色收集）。

  4. 并发清除。

     - 多线程。
     - 不需要暂停，因为不需要移动对象。

     - 清除掉标记阶段判断死亡的对象。

- 基于**标记-清除**算法。只针对老年代。

- 由于 GC 期间，用户线程在运行，老年代要预留区域供用户线程使用。

  - 不能像其他收集器那样，等老年代几乎满了才 GC。
  - JDK 5，默认 68% 就会触发 GC，JDK 6，默认 92%。
  - 如果 Major GC 期间，预留的内存无法满足新对象的分配。则并发失败。
    - 暂停用户线程的执行。启用 Serial Old 收集器来进行老年代的垃圾收集 。

### 缺点

1. 对处理器资源非常敏感。
   - 默认回收线程数时  (CPUS + 3) / 4。
   - 如果有4个以上CPU，只会占用1个CPU，25%资源。
   - 如果少于4个CPU，占用1个CPU，用户线程需要分出一半的运算能力。
2. 无法处理浮动垃圾。
   - 浮动垃圾。在 GC **期间**一些对象成为垃圾，这些对象无法在**本次** GC 回收。
3. 空间碎片。
   - 没有足够大的连续空间分配新对象时，发生 Full GC。

## Garbage First 收集器

- 把堆划分成多个大小相等的独立区域。
  - 每个 Region 根据需要，扮演新生代的Eden和Survivor、老年代空间。
- 一类 Humongous 区域。存储大对象。
  - 超过 Region 容量一半的对象可判定为大对象。
  - G1大多数行为把它作为老年代的一部分看待。
- 建立可预测的停顿时间模型。
  - 将Region作为单次回收的最小单元。
  - 统计计算每个Region回收需要的时间和可以获得空间大小的经验值。
  - 选取回收率高的Region去回收。

- 跨 Region引用对象。

  - 每个Region维护自己的记忆集，记录其他Region指向自己的指针。
  - 耗费约堆容量10%-20%的额外内存。

- 四个步骤。

  1. 初始标记。

     - 单线程。
     - 需要暂停。

  2. 并发标记。

     - 多线程。
     - 不需暂停。

     - 需要预留空间，供新对象分配。

  3. 最终标记。

     - 多线程。

     - 需要暂停。
     - 处理并发标记期间变动的对象（原始快照法）。

  4. 筛选回收。

     - 多线程。

     - 需要暂停。
     - 根据用户参数，指定回收计划。
     - 把需要回收的 Region 的存活对象复制到新的Region。

- 如果无法分配新的对象，触发 Full GC。
- 停顿时间不能设置太低。
  - 太低，每次只能回收很少的 Region。
  - 收集的速度跟不上分配的速度，不断触发 Full GC。

# 内存分配策略

- 大多数情况下，对象在新生代 Eden 区中分配。当 Eden 区没有足够空间进行分配时，虚拟机发起一次 Minor GC。
- 需要大量连续内存的对象（长字符串、数组），直接在老年代分配。
- 在GC 时，年龄超过阈值的对象进入老年代。
  - 对象年龄计数器，存储在对象头。
  - 每次从Survivor存活，年龄加1。
- 如果Survivor空间中，相同年龄的对象大小综合超过Survivor空间的一般。年龄大于等于这个年龄的对象进入老年代。
- 空间分配担保。
  - 如果 Minor GC 期间，ToSurvivor 区无法放下存活的对象。要把存活的对象提前转移到老年代。
  - 因此，要保证老年代放得下。在 Minor GC 之前，JVM检查老年代最大可用的连续空间是否大于新生代所有对象总空间。
    - 如果成立，本次 Minor GC 是安全。
    - 否则，如果 `-XX:HandlePromotionFailure`允许担保失败。检查是否大于历次晋升到老年代对象的平均大小。如果大于，将尝试进行一次 Minor GC。
      - JDK 6 Update 24 后，这个参数无效。总是允许担保失败。
    - 否则，进行 Full GC。