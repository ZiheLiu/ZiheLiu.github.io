---
title: 2. Java 并发机制的底层实现原理
date: 2020-03-04 14:48:02
tags:
	- java
	- concurrency
categories:
	- java	
	- concurrency
typora-root-url: ../../../../
---

# 2. Java 并发机制的底层实现原理

## 1. 锁总线与锁缓存

原子操作和 `volatile` 基于锁总线或锁缓存实现。

### 锁总线

使用 CPU 提供的 LOCK# 信号，当一个 CPU 在总线上处理此信号时，其他 CPU 的操作请求将被阻塞住。因此这个处理器可以独占共享内存。

### 锁缓存

如果内存区域被缓存在 CPU 的缓存行中、并在 Lock 操作期间被锁定，那么当它执行锁操作写回到内存时，CPU 不在总线上声言 LOCK# 信号，而是使用缓存一致性机制来保证操作的原子性。

**缓存一致性机制**，当一个CPU 对缓存中的数据进行操作后，通知其他 CPU 放弃储存在它们内部的缓存，或者从主内存中重新读取。使用 [MESI （修改、独占、共享、无效）协议](https://blog.csdn.net/qq_35642036/article/details/82801708)实现。

如果操作的数据不能被缓存在 CPU 内、或操作的数据跨多个缓存行，则**不会使用锁缓存**，而是锁总线。

## 2. volatile

### 语义

一个字段被声明为 `volatile`，Java 线程内存模型确保所有线程看到这个变亮的值是一致的。

### 原理

1. 汇编中添加 lock 指令。使用锁缓存机制、或使用锁总线机制，引起 CPU 缓存写回到内存。
2. 一个 CPU 缓存回内存，根据 MESI 协议，使其他处理器的缓存无效。

### 使用技巧

可以把使用 `volatile` 的变量追加到 64 字节。否则其他数据和它共用一个缓存行，在它写数据时，会锁缓存行，导致其他 CPU 的其他数据的缓存也失效。

因此在频繁写 `volatile` 变量的场景，可以使用追加字节的方式，避免缓存数据的相互锁定。

## 3. synchronized

### 语法

1. 普通同步方法，锁当前的实例对象。
2. 同步方法块，锁当前的类的 Class 对象。
3. 静态同步方法，锁 `synchronized` 括号中的对象。

### 原理

> 主要参考 [死磕Synchronized底层实现](https://github.com/farmerjohngit/myblog/issues/12)

编译器会在同步代的开始位置前添加 `monitorenter` 指令，在方法结束处、异常处添加 `monitorexit` 指令。

当线程执行到 `monitorenter` 指令，会尝试获取对象所对应的 `monitor` 的所有权，即尝试获得对象锁。

### 锁的三种形式

大多数情况，锁不仅不存在多线程竞争，而且总是同以线程多次获得。因此，设计了三级锁：偏向锁、轻量级锁、重量级锁。

对象的锁的信息存储在对象头里。

![对象头](/images/对象头.jpeg)

其中，

- 在为重量级锁时，指针指向`monitor` 对象。这个对象存储了关于等待的线程们的各种数据结构。

- 偏向锁和重量级锁，使用自己线程栈中的 `lock record` 来记录重入的次数，存储了要锁的对象 `obj`、加锁前对象头的内容 `displaced_markword`。

### 偏向锁

1.6 以上，JVM 默认开启偏向锁。

#### 加锁过程

1. 如果还没有加过锁，尝试 CAS 加锁，将 `markword` 更新为自己线程的 id。
   - 成功，则获得了偏向锁，返回。
   - 失败，将偏向锁撤销，升级为轻量级锁。
2. 如果加过锁，并且 `markword` 中是自己线程的id，即重入了，在自己线程的栈中添加一条 `displaced_markdowrd` 为空的 Lock Recoard。因为是自己栈的变量，这里没有 CAS 操作。
3. 如果加过锁，并且不是自己线程加的锁，则将偏向锁撤销，升级为轻量级锁。

#### 撤销锁

在 `safepoint` 中去查看偏向的线程是否还存活。

- 如果存活、且还在同步块中（看持有锁线程是否有还指向锁对象的 `lock record`），则将锁升级为轻量级锁，原偏向的线程继续拥有锁，当前线程则走入到锁升级的逻辑里。
- 如果偏向的线程已经不存活或者不在同步块中，则将对象头的`markword`改为无锁状态（unlocked），之后再升级为轻量级锁。

#### 释放锁过程

将栈中所有 `obj` 为要释放的锁对象的 `lock record` 的 `obj` 置为 null。（其实，还会查看锁是否是轻量级锁或重量级锁，来进行解锁操作）。

注意，没有修改对象头中的 thread id。

### 轻量级锁

#### 加锁过程

1. 在线程栈中创建一个 `lock record`，将 `obj` 指向锁对象。
2. 用 CAS 尝试将 `lock record` 的地址存储在锁对象头的中。
   - 成功，说明加锁成功，返回。
   - 失败，看是否是当前线程持有的锁。
     - 是的，那么这一次是重入的，设置第一步创建的 `lock record` 的 `displaced_markword` 为 null，起到重入计数的作用。返回。
     - 不是，说明发生了锁竞争，膨胀为重量级锁（会把锁对象头的 markword 更新为持有锁线程的 monitor。

问题：轻量级锁也是发现锁竞争，就膨胀为重量级锁，这样它存在的意义是什么？

- 如果只有两个线程 A 和 B，A 获得偏向锁，B申请锁，锁升级为轻量级锁。之后B获得的锁为轻量级锁，只有第三个线程竞争锁，才会膨胀Wie重量级锁。

#### 解锁过程

1. 遍历线程栈，找到所有 `obj` 为当前锁对象的 `lock record`。
   - 如果 `lock record` 的 `displaced_markword` 为 null，是重入，将 `obj` 设为 null，continue。
   - 如果不为 null，用 CAS 将锁对象头恢复为 `displaced_makrdword`，成功则退出，失败则膨胀重量级锁再进行解锁（可能是其他线程尝试加锁，膨胀为重量级锁，修改了对象头）。

### 重量级锁

重量级锁使用 `Monitor` 实现。

- owner 指向持有锁的线程。
- 当一个线程尝试获得锁，如果该锁已经被占用，则会将该线程封装成一个 ObjectWaiter 对象插入到 cxq 的队列尾部，然后暂停当前线程。当持有锁的线程释放锁前，会将cxq中的所有元素移动到EntryList中去，并唤醒EntryList的队首线程。
- 一个线程调用了`Object#wait`方法，会将该线程的 ObjectWaiter 从 EntryList 移除并加入到 WaitSet 中，然后释放锁。当 wait 的线程被 notify 之后，会将对应的 ObjectWaiter 从 WaitSet 移动到 EntryList 中。

![重量级锁](/images/重量级锁.png)

#### 获取锁

1. 尝试自旋获得锁。
2. 一定次数没有获得后，将当前线程插入到cxq队列的队首。
3. park 当前线程。
4. 当被唤醒后再尝试获得锁（只会尝试一次，不会自旋了）。

#### 释放锁

1. 设置owner为null，即释放锁，这个时刻其他的线程能获取到锁。这里是一个非公平锁的优化。

2. 如果当前没有等待的线程则直接返回就好了，因为不需要唤醒其他线程。或者如果说 succ 不为 null，代表当前已经有个"醒着的"继承人线程，那当前线程不需要唤醒任何线程。

3. 当前线程重新获得锁，因为之后要操作 cxq 和 EntryList 队列以及唤醒线程。

4. 根据QMode的不同，会执行不同的唤醒策略；
   - QMode = 2且cxq非空：取cxq队列队首的ObjectWaiter对象，唤醒ObjectWaiter对象的线程，返回。
   - QMode = 3且cxq非空：把cxq队列插入到EntryList的尾部；
   - QMode = 4且cxq非空：把cxq队列插入到EntryList的头部；
   - QMode = 0：暂时什么都不做，继续往下看。0 为**默认值**。

5. 如果 EntryList 为空，就将cxq的所有元素放入到EntryList中。
6. 取出 EntryList 的首元素，唤醒ObjectWaiter对象的线程。

