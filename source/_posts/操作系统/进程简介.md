---
title: 进程简介
date: 2020-03-05 15:58:45
categories:
	- 操作系统
tags:
	- 操作系统
	- 进程
---

# 进程间通信

## 引用

- [进程间通信的7种方式你都了解吗-知乎](https://zhuanlan.zhihu.com/p/82840452)

## 定义

每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到。

所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程 A 把数据从用户空间拷到内核缓冲区，进程 B 再从内核缓冲区把数据读走，内核提供的这种机制称为**进程间通信**。

##  七种方式

1. PIPE：匿名管道。只能在父子进程、或兄弟进程间。实现原理，在内核中开辟了一个区域，作为文件。只能一个方向写，一个方向读。
2. FIFO：命名管道。开辟的内存区域所表示的文件加了路径名，所以所有进程都可以访问。管道是特殊类型的文件，在满足先入先出的原则条件下可以进行读写，但不能进行定位读写
3. 共享内存。
4. 信号。一个进程可以在任何时候发送一个信号给其他进程。
5. 消息(Message)队列。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比FIFO更有优势。
6. 信号量(semaphore)。信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步
7. socket。

## 信号

进程可以不管对方进程的状态而发送信号。

### 信号的状态

- 产生
- 被传递

### 对信号的操作

#### 阻塞信号

某一种信号可以被对方进程阻塞（发送但是未传递），一直到对方接触这个信号的阻塞才能传递。

同一时刻，一个信号只能阻塞一个，其他同种信号会被丢弃。

#### 屏蔽信号

被屏蔽的某一种信号，会被看做传递了，即消失了。

#### 取消信号

如果对方进程停止运行了，则取消信号。

#### SIGKILL 和 SIGSTOP 信号

SIGKILL 和 SIGSTOP 信号不可被屏蔽、阻塞、忽略，必须执行缺省操作。特权用户使用他们来终止进程/暂停进程（可以用信号SIGCONT恢复）。

### 内核与信号

- 信号处理程序是在**用户态**的，可以重入。
- 信号产生后，如果对方进程没有在运行状态，这个信号要由**内核保存**，直到进程恢复执行。因此，每个进程在从**内核态进入用户态**时，都要**检查**是否有信号要处理。

# 进程的内存分布

## 堆栈段

- 堆
  - 存放进程运行中被动态分配的内存段。
  - 大小并不固定，可动态扩张或缩减。
  - 需要手动申请、释放内存。
- 栈 
  - 存放程序的局部变量、函数参数、函数返回值。
  - 大小固定。
  - 由于栈的先进先出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。

## 数据段

数据段（Data Segment）存放程序中**已初始化**的**全局变量**的一块内存区域。

数据段属于静态内存分配。

## BSS段

BSS段（Block Started by Symbol Segment）存放程序中未初始化的全局变量的一块内存区域。

BSS段属于静态内存分配。

## 代码段

代码段（Code Segment/Text Segment）。程序段为程序代码在内存中的映射。

一个程序可以在内存中多有个副本。

特点：

- 存放程序执行代码 的一块内存区域。

- 也有可能包含一些只读的常数变量，例如字符串常量等。

- 只读
  - 区域的大小在程序运行前就已经确定，并且内存区域通常属于只读 。
  - 某些架构也允许代码段为可写，即允许修改程序。

# 进程和线程

## 引用

- [进程、线程、以及它们之间的区别与联系](https://zhuanlan.zhihu.com/p/60248566)
- [谈谈进程和线程的区别](https://zhuanlan.zhihu.com/p/46410285)

## 根本区别

- 进程是操作系统资源分配的基本单位。
- 线程是任务调度和执行的基本单位。

## 对比

- 进程都有独立的代码和数据空间（程序上下文）。
- 进程之间的切换会有较大的开销
- 线程可以看做轻量级的进程，同一类线程**共享代码和数据空间**，每个线程都有自己独立的运行栈和程序计数器（PC）。
- 线程之间切换的开销小。

# 进程的状态

## 引用

- [进程状态与僵尸进程、孤儿进程](https://zhuanlan.zhihu.com/p/96098130) 

## 状态种类

### 概念上进程的状态

- 创建
- 就绪
- 运行
- 阻塞
- 终止

### Linux 中进程的状态

Linux中，进程的状态：

- 运行
- 睡眠（可中断睡眠）
- 磁盘休眠（不可中断睡眠，等待IO技术）
- 停止状态，SIGSTOP
- 死亡状态
- 僵死状态

## 僵死进程

- 在父进程调用 `fork` 后，产生子进程。

- 子进程在结束运行后，子进程的退出状态（返回值）会回报给操作系统，系统以 `SIGCHLD` 信号将子进程被结束的**事件告知**父进程，此时子进程的进程控制块 PCB 仍驻留在内存中。
  - 收到 `SIGCHLD` 后，父进程会使用 `wait()`系统调用以获取子进程的退出状态，内核就可以从内存中释放已结束的子进程的 PCB。
  - 如果父进程没有这么做，子进程的 PCB 就会一直驻留在内存中，也即成为僵尸进程。

简单来说，当进程退出但是父进程并没有调用 `wait()` 或 `waitpid()` 获取子进程的状态信息时就会产生僵尸进程。

## 孤儿进程

当一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。

孤儿进程将被 init 进程（进程号为1）所收养，并由 init 进程对它们完成状态收集工作。

# 软中断

> - [Linux的中断处理机制(四) ](https://zhuanlan.zhihu.com/p/80371745)

中断的上半段不能被延后执行，而下半段可以。

下半段被称为软中断。

# fork/vfork/clone

- `fork` 使用 `clone` 实现。
  - 传入的 `flags` 是 SIGCHILD 信号、所有清0的 clone标志位。
  - 写时复制机制。父子进程暂时共享一个用户态堆栈，只要父子进程有一个试图去改变栈，立即得到用户态堆栈的一份拷贝。
- `vfork` 使用 `clone` 实现。
  - 传入 SIGCHILD 信号、CLONE_VM、CLONE_VFORK。
  - 创建的进程能共享父进程的内存地址空间，因此需要阻塞父进程的执行，直到子进程调用 `exec()` 或 `exit()` 。

## exec()   

 exec函数族提供了一种在进程中**启动另一个程序**执行的方法。

可以根据指定的文件名、或目录名找到可执行文件，并用它来取代原调用进程的数据段、代码段、堆栈段。

在执行完之后，原调用进程的内容除了 PID 外，其他全部都被替换了。

# 会话与进程组

> - [linux会话浅析](https://yq.aliyun.com/articles/8874  )
> - [[linux下的SIGHUP系统信号](https://www.cnblogs.com/klb561/p/12051027.html)](https://www.cnblogs.com/klb561/p/12051027.html)

## 进程组

线程组是一组进程的集合，可以一次性送信号给进程组的所有进程。

一个进程组的进程一般都是由一个进程创建出来的，它是 leader 进程。进程组的 PGID 是这个 leader 进程的 PID。

可以使用 `setpgid(pid, pgid)` 来设置进程的进程组。

## 会话 session

会话是一组线程组的集合。

一个会话最多有一个控制终端（可以没有）。

用来建立起控制终端连接的进程是会话的 leader 进程，会话的 SID 是这个 leader 进程的 PID。

前台和后台进程组

- 一个会话只有一个**前台**进程组，可以和终端交互。
- 一个会话可以有多少**后台**进程组，是通过加入 `&` 参数来实现的。
  - `&` 会忽略 SIGINT 信号（来自键盘的中断）。

可以使用 `setsid(pid, sid)` 来设置进程的会话，但是不能是会话的 leader 继承。

## 终端关闭

1. 终端关闭时，`SIGHUP` 信号被发送到会话的 leader 首进程、以及后台进程。
2. 会话 leader 进程退出时，`SIGHUP` 该信号被发送到前台进程组中的每一个进程。

## nohup

使用 `nohup`

- 可以使进程忽略 SIGHUP 信号。

- 还会将进程的标准输入重定向为 `/dev/null`、输出重定向到 `nohup.out` 文件。

使用 `nohup &`。

- 可以使进程在后台运行, 忽略 `SIGINT`、`SIGHUP` 信号，输出到 nohup.out，关闭会话进程不结束。