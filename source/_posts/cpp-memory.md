---
title: C++ 内存管理技术内幕
date: 2023-03-29 22:29:22
categories:
	- C++
tags:
	- C++
typora-root-url: ../
---

# 0. 导语

内存管理是 C++ 最令人切齿痛恨的问题，也是 C++ 最有争议的问题，C++ 高手从中获得了更好的性能、更大的自由，C++ 菜鸟的收获则是一遍一遍的检查代码和对 C++ 的痛恨，但内存管理在 C++ 中无处不在，内存泄漏几乎在每个 C++ 程序中都会发生，因此要想成为C++ 高手，内存管理一关是必须要过的， 除非放弃 C++，转到 Java 或者 .NET，他们的内存管理基本是自动的，当然你也放弃了自由和对内    存的支配权，还放弃了 C++ 超绝的性能。本期专题将从内存管理、内存泄漏、内存回收这三个方面来探讨 C++ 内存管理问题。



# 1. 内存管理

伟大的 Bill Gates 曾经失言：

> 640K ought to be enough  for everybody - Bill  Gates 1981

程序员们经常编写内存管理程序，往往提心吊胆。如果不想触雷，唯一的解决办法就是发现所有潜伏的地雷并且排除它们，躲是躲不了的。本文的内容比一般教科书的要深入得多，读者需细心阅读，做到真正地通晓内存管理。

## 1.1. C++内存管理详解

### 1.1.1. 内存分配方式
#### 1.1.1.1. 分配方式简介

在 C++ 中，内存分成 5 个区，他们分别是栈、堆、自由存储区、全局／静态存储区、常量存储区。

- 栈。   
  在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
- 堆。   
  就是那些由 `new` 分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个 `new` 就要对应一个 `delete`。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。
- 自由存储区。   
  就是那些由 `malloc` 等分配的内存块，它和堆是十分相似的，不过它是用 `free` 来结束自己的生命的。
- 全局／静态存储区。   
  全局变量和静态变量被分配到同一块内存中。在以前的 C 语言中，全局变量 又分为初始化的和未初始化的；在 C++ 里面没有这个区分了，它们共同占用同一块内存区。
- 常量存储区。   
  这是一块比较特殊的存储区，它们里面存放的是常量，不允许修改。

#### 1.1.1.2. 明确区分堆与栈

在 bbs 上，堆与栈的区分问题，似乎是一个永恒的话题。由此可见，初学者对此往往是混淆不清的，所以我决定拿它第一个开刀。

首先，我们举一个例子：

```C++
void f() {
	int* p = new int[5];
}
```

这条短短的一句话就包含了堆与栈。看到 `new`，我们首先就应该想到，我们分配了一块堆内存，那么指针 `p` 呢？他分配的是一块栈内存，所以这句话的意思就是：在栈内存中存放了一个指向一块堆内存的指针 `p`。程序会先确定在堆中分配内存的大小，然后调用 `operator new` 分配内存，然后返回这块内存的首地址，放入栈中，他在 VC6 下的汇编代码如下：

```assembly
00401028 push 14h
0040102A call operator new (00401060)
0040102F add esp,4
00401032 mov dword ptr [ebp.-8],eax 
00401035 mov eax,dword ptr [ebp-8]
00401038 mov dword ptr [ebp-4],eax
```

这里，我们为了简单井没有释放内存，那么该怎么去释放呢？是 `delete p` 么？奥，错了，应该是 `delete []p`，这是为了告诉编译器：我删除的是一个数组，VC6 就会根据相应的 Cookie 信息去进行释放内存的工作。

#### 1.1.1.3. 堆和栈究竟有什么区别？       

好了，我们回到我们的主题：堆和栈究竟有什么区别？

主要的区别有以下几点：

1. 管理方式不同；
2. 空间大小不同；
3. 能否产生随便不同；
4. 生长方向不同；
5. 分配方式不同；
6. 分配效率不同；

**管理方式**：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生 memory leak。

**空间大小**：一般来讲在 32 位系统下，堆内存可以达到 4GB 的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在 VC6 下面，默认的栈空间大小是 1MB（好像是，记不清楚了）。当然，我们可以修改：

打开工程，依次操作菜单如下：Project->Setting->Link，在 Category 中选中 Output，然后在 Reserve 中设定堆栈的最大值和 commit。

注意：reserve 最小值为 4B；commit 是保留在虚拟内存的页文件里面，它设置的较大会使栈开辟较大的值，可能增加内存的开销和启动时间。

**碎片问题**：对于堆来讲，频繁的 `new`/`delete` 势必会造成内存空间的不连续，从而造成大量的 碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出，详细的可以参考数据结构，这里我们就不再一一讨论了。

**生长方向**：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。

**分配方式**：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由 `alloca` 函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。

**分配效率**：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是 C/C++ 函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构／操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是 由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。

从这里我们可以看到，堆和栈相比，由于大量 `new`/`delete` 的使用，容易造成大量的内存碎片；由于没有专门的系统支持，效率很低；由于可能引发用户态和核心态的切换，内存的申请，代价变得更加昂贵。所以栈在程序中是应用最广泛的，就算是函数的调用也利用栈去完成，函数调用过程中的参数、返回地址、EBP 和局部变量都采用栈的方式存放。所以，我们推荐大家尽量用栈，而不是用堆。

虽然栈有如此众多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，还是用堆好一些。

无论是堆还是栈，都要防止越界现象的发生（除非你是故意使其越界），因为越界的结果要么是程序崩溃，要么是摧毁程序的堆、栈结构，产生意想不到的结果，就算是在你的程序运行过程中，没有发生上面的问题，你还是要小心，说不定什么时候就崩掉，那时候 debug 可是相当困难的 :) 

### 1.1.2. 控制 C++ 的内存分配

在嵌入式系统中使用 C++ 的一个常见问题是内存分配，即对 `new` 和 `delete` 操作符的失控。

具有讽刺意味的是，问题的根源却是 C++ 对内存的管理非常的容易而且安全。具体地说，当一个对象被消除时，它的析构函数能够安全的释放所分配的内存。

这当然是个好事情，但是这种使用的简单性使得程序员们过度使用 `new` 和`delete`，而不注意在嵌入式 C++ 环境中的因果关系。井且，在嵌入式系统中，由于内存的限制，频繁的动态分配不定大小的内存会引起很大的问题以及堆破碎的风险。

作为忠告，保守的使用内存分配是嵌入式环境中的第一原则。

但当你必须要使用 `new` 和 `delete` 时，你不得不控制 C++ 中的内存分配。你需要用一个全局的 `new` 和 `delete` 来代替系统的内存分配符，井且一个类一个类的重载 `new` 和 `delete`。

一个防止堆破碎的通用方法是从不同固定大小的内存池中分配不同类型的对象。对每个类重载 `new` 和 `delete` 就提供了这样的控制。

#### 1.1.2.1. 重载全局的 new 和 delete 操作符

可以很容易地重载 `new` 和 `delete` 操作符，如下所示：

 ```C++
 void* operator new(size_t size) {
   void* p = malloc(size);
   return (p);
 }
 
 void* operator delete(void* p) {
   free(p);
 }
 ```

这段代码可以代替默认的操作符来满足内存分配的请求。出于解释 C++ 的目的，我们也可以直接调用 `malloc()` 和 `free()`。

也可以对单个类的 `new` 和 `delete` 操作符重载。这使你能灵活的控制对象的内存分配。

```C++
class TestClass {
public:
  void* operator new(size_t size);
  void operator delete(void* p);
  // ... other members here ...
};

void* TestClass::operator new(size_t size) {
  void* p = malloc(size); // Replace this with alternative allocator
  return (p);
}

void TestClass::operator delete(void* p) {
  free(p); // Replace this with alternative de-allocator
}
```

所有 `TestClass` 对象的内存分配都采用这段代码。更进一步，任何从 `TestClass` 继承的类也都采用这一方式，除非它自己也重载了 `new` 和 `delete` 操作符。通过重载 `new` 和 `delete` 操作符的方法，你可以自由地采用不同的分配策略，从不同的内存池中分配不同的类对象。

#### 1.1.2.2. 为单个的类重载 new[] 和delete[]

必须小心对象数组的分配。你可能希望调用到被你重载过的 `new` 和 `delete` 操作符，但并不如此。内存的请求被定向到全局的 `new[]` 和 `delete[]`操作符，而这些内存来自于系统堆。

C++ 将对象数组的内存分配作为一个单独的操作，而不同于单个对象的内存分配。为了改变这种方式，你同样需要重载 `new[]` 和 `delete[]` 操作符。

```C++
class TestClass {
public:
  void* operator new[](size_t size);
  void operator delete[](void* p);
  // ... other members here ...
};

void* TestClass::operator new[](size_t size) {
  void* p = malloc(size);
  return (p);
}

void TestClass::operator delete[](void* p) {
  free(p);
}

int main(void) {
  TestClass* p = new TestClass[10];
  // ... etc ...
  delete[] p;
}
```

但是注意：对于多数 C++ 的实现，`new[]` 操作符中的个数参数是数组的大小加上额外的存储对象数目的一些字节。在你的内存分配机制重要考虑的这一点。你应该尽量避免分配对象数组，从而使你的内存分配策略简单。

### 1.1.3. 常见的内存错误及其对策

发生内存错误是件非常麻烦的事情。编译器不能自动发现这些错误，通常是在程序运行时才能捕捉到。而这些错误大多没有明显的症状，时隐时现，增加了改错的难度。有时用户怒气冲冲地把你找来，程序却没有发生任何问题，你一走，错误又发作了。常见的内存错误及其对策如下：

- 内存分配未成功，却使用了它。    
  编程新手常犯这种错误，因为他们没有意识到内存分配会不成功。常用解决办法是，在使用内存之前检查指针是否为 `NULL`。如果指针 `p` 是函数的参数，那么在函数的入口处用 `assert(p!=NULL)` 进行检查。如果是用 `malloc` 或 `new` 来申请内存，应该用 `if (p==NULL)` 或 `if(p!=NULL)` 进行防错处理。
- 内存分配虽然成功，但是尚未初始化就引用它。   
  犯这种错误主要有两个起因：一是没有初始化的观念；二是误以为内存的缺省初值全为零，导致引用初值错误（例如数组）。内存的缺省初值究竟是什么井没有统一的标准，尽管有些时候为零值，我们宁可信其无不可信其有。所以无论用何种方式创建数组，都别忘了赋初值，即便是赋零值也不可省略，不要赚麻烦。
- 内存分配成功井且已经初始化，但操作越过了内存的边界。   
  例如在使用数组时经常发生下标”加 1”或者“减 1”的操作。特别是在 `for` 循环语句中，循环次数很容易搞错，导致数组操作越界。
- 忘记了释放内存，造成内存泄漏。   
  含有这种错误的函数每被调用一次就丢失一块内存。刚开始时系统的内存充足，你看不到错误。终有一次程序突然死掉，系统出现提示：内存耗尽。
  动态内存的申请与释放必须配对，程序中 `malloc` 与 `free` 的使用次数一定要相同，否则肯定有错误（`new` / `delete` 同理）。
- 释放了内存却继续使用它。   
  有三种情况：
  1. 程序中的对象调用关系过千复杂，实在难以搞清楚某个对象究竟是否已经释放了内存，此时应该重新设计数据结构，从根本上解决对象管理的混乱局面。
  2. 函数的 `return` 语句写错了，注意不要返回指向“栈内存”的“指针”或者“引用“，因为该内存在函数体结束时被自动销毁。
  3. 使用 `free` 或 `delete` 释放了内存后，没有将指针设置为 `NULL`。导致产生“野指针“。



规则总结    

- 【规则1】用 `malloc` 或 `new` 申请内存之后，应该立即检查指针值是否为 `NULL`。防止使用指针值为 `NULL` 的内存。
- 【规则2】不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。
- 【规则3】避免数组或指针的下标越界，特别要当心发生”加 1“或者”少 1“操作。
- 【规则4】动态内存的申请与释放必须配对，防止内存泄漏。
- 【规则5】用 `free` 或 `delete` 释放了内存之后，立即将指针设置为 `NULL`，防止产生”野指针“。



### 1.1.4. 指针与数组的对比

C/C++ 程序中，指针和数组在不少地方可以相互替换着用，让人产生一种错觉，以为两者是等价的。

- 数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。数组名对应着（而不是指向） 一块内存，其地址与容量在生命期内保持不变，只有数组的内容可以改变。
- 指针可以随时指向任意类型的内存块，它的特征是“可变”，所以我们常用指针来操作动态内存。指针远比数组灵活，但也更危险。

下面以字符串为例比较指针与数组的特性。

#### 1.1.4.1. 修改内容

下面示例中，字符数组 `a` 的容量是 6 个字符，其内容为“hello”。`a` 的内容可以改变，如 `a[0]='X'`。指针 `p` 指向常量字符串“world”（位于静态存储区，内容为“world”)，常量字符串的内容是不可以被修改的。从语法上看，编译器并不觉得语句 `p[0]='X'` 有什么不妥，但是该语句企图修改常量字符串的内容而导致运行错误。

```C++
char a[] = "hello";
a[0] ='X';
cout << a << endl;

char* p = "world";  //注意 p 指向常量字符串
p[0] ='X'; // 编译器不能发现该错误
cout << p << endl;
```

#### 1.1.4.2. 内容复制与比较

不能对数组名进行直接复制与比较。若想把数组 `a` 的内容复制给数组 `b`，不能用语句 `b = a`，否则将产生编译错误。应该用标准库函数 `strcpy` 进行复制。同理，比较 `b` 和 `a` 的内容是否相同，不能用 `if (b==a)` 来判断，应该用标准库函数 strcmp 进行比较。

语句 `p = a` 并不能把 `a` 的内容复制给指针 `p`，而是把 `a` 的地址赋给了 `p`。要想复制 `a` 的内容，可以先用库函数 `malloc` 为 `p` 申请一块容量为 `strlen(a) + 1` 的内存，再用 `strcpy` 进行字符串复制。同理，语句 `if (p==a)` 比较的不是内容而是地址，应该用库函数 `strcmp` 来比较。

 ```C++
 // 数组
 char a[] = "hello";
 char b[10];
 strcpy(b, a); // 不能用 b = a
 if (strcmp(b, a) == 0) { // 不能用 if (b == a)
   // ...
 }
 
 // 指针
 int len = strlen(a);
 char* p = (char*)malloc(sizeof(chat) * (len + 1));
 strcpy(p, a); // 不能用 b = a
 if (strcmp(p, a) == 0) { // 不能用 if (b == a)
   // ...
 }
 ```

#### 1.1.4.3. 计算内存容量

用运算符 `sizeof` 可以计算出数组的容量（字节数）。如下示例中，`sizeof(a)` 的值是 12（注意别忘了 `\0`）。指针 `p` 指向 `a`，但是 `sizeof(p)` 的值却是4。这是因为 `sizeof(p)` 得到的是一个指针变量的字节数，相当于 `sizeof(char*)`，而不是 `p` 所指的内存容量。C/C++ 语言没有办法知道指针所指的内存容最，除非在申请内存时记住它。

```C++
char a[]	= "hello world"; 
char* p = a;
cout<< sizeof(a) << endl;	// 12B
cout<< sizeof(p) << endl;	// 4B
```

注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。如下示例中，不论数组 `a` 的容量是多少，`sizeof(a)` 始终等于 `sizeof(char*)`。

```C++
void Func(char a[100]) {
	cout << sizeof(a)	<< endl;	// 4B 而不是 100B
}
```

